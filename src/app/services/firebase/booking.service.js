import connect from "@/app/config/firebase.config/firebase.connect";
import { ref, set, get, update, remove, push } from "firebase/database";

const { database } = connect.firebase;

const bookingService = {
  getAll: async () => {
    const bookingsRef = ref(database, "booking/");
    try {
      const snapshot = await get(bookingsRef);
      if (snapshot.exists()) {
        const bookings = [];
        snapshot.forEach((childSnapshot) => {
          const bookingId = childSnapshot.key;
          const bookingDetails = childSnapshot.val();
          bookings.push({ bookingId, bookingDetails });
        });
        return bookings;
      } else {
        return [];
      }
    } catch (error) {
      console.error("Error fetching all bookings: ", error);
      return error;
    }
  },
  get: async (bookingId) => {
    const detailsRef = ref(database, `booking/${bookingId}/`);
    try {
      const snapshot = await get(detailsRef);
      if (snapshot.exists()) {
        return snapshot.val();
      } else {
        return null;
      }
    } catch (error) {
      console.error("Error fetching booking details: ", error);
      return error;
    }
  },
  create: async (owner, pickup, dropoff, details, status, rider, price) => {
    const detailsData = {
      owner,
      pickup,
      dropoff,
      details,
      status,
      rider,
      price,
    };

    try {
      const bookingRef = push(ref(database, "booking")); // Push to generate a new child key
      const bookingId = bookingRef.key; // Get the key generated by push
      await set(bookingRef, detailsData); // Set the details under the generated key
      return { bookingId, detailsData };
    } catch (error) {
      throw new Error("Failed to create booking: " + error.message);
    }
  },

  update: async (bookingId, updateData) => {
    const detailsRef = ref(database, `booking/${bookingId}`);
    updateData.updatedAt = new Date().toISOString();
    try {
      await update(detailsRef, updateData);
      return true;
    } catch (error) {
      console.error("Error updating booking details: ", error);
      return error;
    }
  },
  remove: async (bookingId) => {
    const detailsRef = ref(database, `booking/${bookingId}`);
    try {
      await remove(detailsRef);
      return true;
    } catch (error) {
      console.error("Error deleting booking details: ", error);
      return error;
    }
  },
  getBookingsByUser: async (userId) => {
    const bookingsRef = ref(database, "booking/");
    try {
      const snapshot = await get(bookingsRef);
      if (snapshot.exists()) {
        const userBookings = [];
        snapshot.forEach((childSnapshot) => {
          const bookingDetails = childSnapshot.val();
          if (
            bookingDetails.owner === userId ||
            bookingDetails.rider === userId
          ) {
            userBookings.push({ bookingId: childSnapshot.key, bookingDetails });
          }
        });
        return userBookings;
      } else {
        return [];
      }
    } catch (error) {
      console.error("Error fetching bookings by user: ", error);
      return error;
    }
  },
  updateStatus: async (bookingId, status) => {
    const detailsRef = ref(database, `booking/${bookingId}`);
    const updateData = {
      status: status,
      updatedAt: new Date().toISOString(),
    };
    try {
      await update(detailsRef, updateData);
      return true;
    } catch (error) {
      console.error("Error updating booking status: ", error);
      return error;
    }
  },
};

export default bookingService;
